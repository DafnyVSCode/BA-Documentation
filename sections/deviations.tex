\section{Deviations from the project plan}\label{projectCourse}
This chapter details how the project was implemented and in what way it deviated of the project plan.
\subsection{UC3: Reporting of Dafny best practices violations}
While this idea seemed obvious when planning the project, this feature could sadly not be implemented. When working with different IDEs and well established programming languages, a programmer is often used to be supported by tools which can help write cleaner and more idiomatic code, such as linters. From this viewpoint, the integration of such a tool into the plugin seemed necessary. \newline
While established languages have a pool of agreed upon best practices, Dafny is still a very young language with not yet wide spread usage. The tooling around Dafny is also still not as sophisticated yet as for other languages. From this it can be inferred that there is not yet a big collection of programs to gain experience from, and that the problem of establishing a clear work flow with Dafny usually still exists, further preventing programmers to concentrate on idioms. \newline
These facts reflect why there is no collection of best practices for Dafny yet, either in form of some documentation or as a suggestion from people that are involved with Dafny. \newline
A second point worth noting in regard to this use case is how best practices for Dafny could look like. Dafny differs to most other languages in that it provides excellent specification constructs. A natural area to agree on idioms would therefor be the contracts of a piece of code. This could also greatly enhance the performance, because if clever usage is made of techniques such as short circuiting, a proof can be calculated at a much lesser cost than with a naive implementation. \newline
While providing support for best practices for contracts would therefor be very nice, this would also be almost unsolvable complex. Even for simple cases a deep understanding of proof theory would be needed, while for complex conditions it is not determinable if they can be proven in a better way or if they can be specified and proven at all. \newline
Since the establishment of own best practices for Dafny without being able to include an existing collection was deemed an unrealistic, and the structuring of contracts in the best way possible an unsolvable task, it was decided to concentrate on other features of the plugin instead. \newline


\subsection{UC4: Automatic generation of contracts}\label{missinguc4}
Since the biggest selling point of Dafny is the possibility to write specification constructs. It therefor was clear to try to provide automatic generation of some of such constructs in this project. While planning the project, the proof pipeline used by Dafny was not yet understood fully, the grasp on proof theory was quite small as well. This made it very hard to estimate if such a feature could be implemented at all and if so, in what time. Nevertheless the potential benefit of such a feature marked it as a milestone in this project. \newline
While researching the theoretical basis for implementing such a feature as detailed in \ref{examples} and the chapters following it, it became apparent that the topic was quite complex. A first stumbling block were invariants. As languages such as Eiffel \ref{eiffel} make it is to work with invariants, it was assumed that Dafny offers this possibility as well. \newline
As was learned, there are several different methodologies when it comes to invariants, having them implemented as a macro which simply inserts them as postconditions to every block is simply the easiest approach. A collection of techniques can be found in \cite{invariants}. 
Dafny doesn't build in object invariants because it doesn't commit to a particular methodology. Since the upholding of certain business rules (which was the aim of this use case) via specification constrains usually translates into generation of invariants, in addition to generating the invariants, it would have also been in the scope of this project to define how to deal with invariants in Dafny in a consistent work. It was also impossible to define and implement a way in which such business rules could be expressed regarding time and the trade off between usability and flexibility.\newline
The second idea was to apply the concept of the weakest precondition. This means that if a proof does not hold given a context, one can find the weakest precondition to make the proof valid. It would have been great to offer the generation of the weakest precondition as a refactoring in the plugin. However, since the weakest precondition must be expressed in Dafny, it would have to be found in almost human readable form. Z3 \cite{z3}, the theorem prover used by Dafny, tries to prove a theorem via contradiction, it is very hard to gain information about satisfiability from the prover. Additionally there is the problem that Dafny code gets translated to the Boogie\cite{boogie} meta language, which then gets translated to Z3 syntax. Even if one could gain information from Z3 about satisfiability, it would therefor be difficult to provide a matching back to the Dafny language and display this information. In general, the problem of inferring sufficient conditions for proofs is very hard if they should be human readable, the few existing solutions work with an iterative approach relying on stepwise reduction of counter example, for instance described in \cite{preInference}. This approach is difficult to implement and lacks the usability that was sought after in this use case.\newline
Lastly, it took a lot of time to gain a working knowledge of the proof pipeline. Since it consists of three big projects, namely Dafny, Boogie \cite{boogie} and Z3 working together, a deep understanding was not possible without having some existing knowledge in this time. While trying to understand the pipeline, it also became apparent that the knowledge of the authors in proof theory was not deep enough to really grasp the problem and work on a solution in a feasible time. \newline
Because of all these reasons, it was decided to not implement this use case in this project. While this is regrettable, other ideas were gained during the investigation of the problem. The feasibility of displaying counter modules was discovered, as well as small refactorings that provide constraints for a small, but very often needed set of instructions such as array accesses were thought of. The remaining time of this milestone therefor was directed at implementing these features instead. 

\subsection{Code Actions}\label{addCodeActions}
As detailed in \ref{missinguc4}, while trying to implement a proof of concept for contract generation, some often used concepts while working with contracts were discovered. This led to the idea to offer refactorings to generate the correct contracts for these concepts. While this is in no way a generic approach towards contract generation, it seemed as though these refactorings could help in many situations, making life considerably easier for the programmer. It was therefor decided to implement them, partly replacing the goals sought after in use case 4. A more complete picture, including an overview of the implementation, can be found in \ref{quickfixes}. The following list details on why these concepts were chosen. \newline
 
\paragraph{Null Check}
Programmers very often access members of elements, especially in the methodology of object oriented programming. While it offers a great way to structure a program and to represent reality in a program, it comes with some danger. The most common pitfall is what Hoare famously declared his biggest mistake\cite{hoare}, the null reference. To help avoid this, Dafny reports potential null reference. Since almost any piece of complex code deals with objects, this is a very common occurrence, since for instance every object given as an argument must be checked for null first. \newline
It was decided to offer a mitigation of this important, but tedious work. The plugin detects warnings about potential null references, and offers to generate a precondition that demands that the designator standing for the potential null reference may not be null. If the programmer accepts the proposal, the precondition is inserted at the correct location. This shifts the burden of providing a valid context to the caller of the method, so the method can concentrate on offering a solution to the call. While working with Dafny, it was noticed that such a precondition was needed for about every third method, meaning that a lot of work is done for the programmer by supplying this precondition generation.
\paragraph{Bound Checking}
Almost as often as checking for null, it is necessary to check if an index to an array is in bound. Dafny already has sufficient knowledge about the array data structure that it issues a warning every time it is not clear if an index that is used to access an element is in bound of the array. While programming with Dafny, it was observed that this is the case in almost every non trivial example using arrays. Since the array data structure is used quite often in Dafny, it was decided to also help the programmer with this construct, since bound checking is important, but tedious. \newline
Whenever a warning is issued by Dafny that an index may be out of bound, the plugin offers to generate two preconditions, namely one that states that the expression representing the index must be bigger than zero, and one that states it must be smaller then the array length minus one. The placement off course must be so that the preconditions are introduced at a place in the program where all variables used in the expression have been declared. When the programmer decides to use the quick fix, the preconditions are inserted and relieve him of the hassle of manually checking the bounds of the index.
\paragraph{Increase / Decrease / Invariant Guards}
Another concept that often arises when using Dafny is to make sure an expression converges to a certain range of values over time. This is the case when making use of recursion to ensure that the base case is eventually met, or when writing loops that depend on a certain value of an expression for termination. Both examples are very important, because not handling them correctly can result in endless loops or overflow. Dafny already does a good job in generating warnings that tell the programmer that constraints should be enforced for a certain expression. \newline
These situations also occur very often, since both recursion and loops are fundamental elements of programming, it was decided that the generation of these constraints could greatly benefit the programmer. In order to do this, the plugin offers to add an increase / decrease clause with the correct expression in place when Dafny detects recursion or a loop. When the programmer chooses to use the quick fix, the guard statements are inserted at the correct place. Another important constraint when working with loops goes hand in hand with the use case described above, namely when an array is accessed within a loop and the expression used as an index is not constant within the context of the loop. For this, Dafny offers the construct of invariants, that ensure that an expression is within a certain range during a given context. The plugin therefor offers to generate invariants which ensure that an expression used as an index is always in bound of the array. When the programmer chooses to use this feature, the invariant is inserted at the correct context. 

\subsection{Counter Examples}
A concept which was not known as the project started, were counter examples. They provide a huge benefit, as to understand how a program violates its contract. Especially if it is a more complex software with many methods and many branches, it can be very difficult to understand why a contract does not hold\newline
For this reason it was decided to implement that feature in addition to CodeActions \ref{addCodeActions}. 
Developers can use this practical features directly in Visual Studio Code. It shows on each line how the variables have to be assigned that the proof fail. \newline
Because the calculation of the model, how it is called in Z3, can take very long, it is not calculated automatically if a proof fails. Nevertheless this can be overridden in the configuration. 

 
\subsection{Displaying Flow Graph}
Something which is already implemented in Boogie, is the generation of a Flow Graph out of a boogie program. Because this could be quite useful for developers, it was decided to implement this feature as well. Mainly because it can be implemented so, that on one side is the source code and next to it, the flow graph. It displays the program visually including all pre- and postconditions. 