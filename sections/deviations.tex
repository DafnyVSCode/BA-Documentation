\subsection{Deviations from the project plan}

\subsubsection{UC3: Reporting of Dafny best practices violations}
While this idea seemed obvious when planning the project, this feature could sadly not be implemented. When working with different IDEs and well established programming languages, a programmer is often used to be supported by tools which can help write cleaner and more idiomatic code, such as linters. From this viewpoint, the integration of such a tool into the plugin seemed necessary. \newline
While established languages have a pool of agreed upon best practices, Dafny is still a very young language with not yet wide spread usage. The tooling around Dafny is also still not as sophisticated yet as for other languages. From this it can be inferred that there is not yet a big collection of programs to gain experience from, and that the problem of establishing a clear work flow with Dafny usually still exists, further preventing programmers to concentrate on idioms. \newline
These facts reflect why there is no collection of best practices for Dafny yet, either in form of some documentation are as a suggestion from people that are involved with Dafny. \newline
A second point worth noting in regard to this use case is how best practices for Dafny could look like. Dafny differs to most other languages in that it provides excellent specification constructs. A natural area to agree on idioms would therefor be the contracts of a piece of code. This could also greatly enhance the performance, because if clever usage is made of techniques such as short circuiting, a proof can be calculated at a much lesser cost than with a naive implementation. \newline
While providing support for best practices for contracts would therefor be very nice, this would also be almost unsolvable complex. Even for simple cases a deep understanding of proof theory would be needed, while for complex conditions it is not determinable if they can be proven in a better way or if they can be specified and proven at all. \newline
Since the establishment of own best practices for Dafny without being able to include an existing collection was deemed an unrealistic, and the structuring of contracts in the best way possible an unsolvable task, it was decided to concentrate on other features of the plugin instead. \newline


\subsubsection{UC4: Automatic generation of contracts}
Since the biggest selling point of Dafny is the possibility to write specification constructs. It therefor was clear to try to provide automatic generation of some of such constructs in this project. While planning the project, the proof pipeline used by Dafny was not yet understood fully, the grasp on proof theory was quite small as well. This made it very hard to estimate if such a feature could be implemented at all and if so, in what time. Nevertheless the potential benefit of such a feature marked it as a milestone in this project. \newline
While researching the theoretical basis for implementing such a feature as detailed in \ref{examples} and the chapters following it, it became apparent that the topic was quite complex. A first stumbling block were invariants. As languages such as Eiffel \ref{eiffel} make it is to work with invariants, it was assumed that Dafny offers this possibility as well. \newline
As was learned, there are several different methodologies when it comes to invariants, having them implemented as a macro which simply inserts them as postconditions to every block is simply the easiest approach. A collection of techniques can be found in \cite{invariants}. 
Dafny doesn't build in object invariants because it doesn't commit to a particular methodology. Since the upholding of certain business rules (which was the aim of this use case) via specification constrains usually translates into generation of invariants, in addition to generating the invariants, it would have also been in the scope of this project to define how to deal with invariants in Dafny in a consistent work. It was also impossible to define and implement a way in which such business rules could be expressed regarding time and the trade off between usability and flexibility.\newline
The second idea was to apply the concept of the weakest precondition. This means that if a proof does not hold given a context, one can find the weakest precondition to make the proof valid. It would have been great to offer the generation of the weakest precondition as a refactoring in the plugin. However, since the weakest precondition must be expressed in Dafny, it would have to be found in almost human readable form. Z3 \cite{z3}, the theorem prover used by Dafny, tries to prove a theorem via contradiction, it is very hard to gain information about satisfiability from the prover. Additionally there is the problem that Dafny code gets translated to the Boogie\cite{boogie} meta language, which then gets translated to Z3 syntax. Even if one could gain information from Z3 about satisfiability, it would therefor be difficult to provide a matching back to the Dafny language and display this information. In general, the problem of inferring sufficient conditions for proofs is very hard if they should be human readable, the few existing solutions work with an iterative approach relying on stepwise reduction of counter example, for instance described in \cite{preInference}. This approach is difficult to implement and lacks the usability that was sought after in this use case.\newline
Lastly, it took a lot of time to gain a working knowledge of the proof pipeline. Since it consists of three big projects, namely Dafny, Boogie \cite{boogie} and Z3 working together, a deep understanding was not possible without having some existing knowledge in this time. While trying to understand the pipeline, it also became apparent that the knowledge of the authors in proof theory was not deep enough to really grasp the problem and work on a solution in a feasible time. \newline
Because of all these reasons, it was decided to not implement this use case in this project. While this is regrettable, other ideas were gained during the investigation of the problem. The feasibility of displaying counter modules was discovered, as well as small refactorings that provide constraints for a small, but very often needed set of instructions such as array accesses were thought of. The remaining time of this milestone therefor was directed at implementing these features instead. \newline


