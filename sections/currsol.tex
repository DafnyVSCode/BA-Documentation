\subsection{Current Solutions}\label{cursol}
This chapter details what shortcomings current solutions in this area have and where there is room for improvement. Rather than offering a checklist of each solution in regard to its features, another approach is chosen in this chapter. Important concepts of an ideal solution that satisfies the main objectives detailed in \ref{mainGoal} are listed, combined with how most current solutions perform regarding the concept. When an existing solution stands out in some way, it may be named specifically. \newline

\subsubsection{Platform Independence}
With three well established operating systems being used by different programmers, it is not feasible to have a solution that only works on one platform. There is often a trade off is this area regarding using powerful platform specific APIs and having a portable solution. While many other languages are supported by rich platform independent IDEs such as Eclipse \cite{eclipse} or those provided by JetBrains \cite{jetbrains}, the current solutions for Dafny still lack in this area. \newline
Most IDEs that support Dafny only work correctly on Windows, Emacs \cite{GNU} with it's Dafny plugin is the only solution that works across all platforms. Emacs, while being a heavily used IDE, is an IDE with a very special methodology that does not suit all programmers, narrowing the range of people that can be reached by a Dafny integration. Further there are some cross platform IDEs that offer support for Dafny, for instance the old Dafny plugin for Visual Studio Code, but with those the integration itself does not work across all platforms. \newline
This evaluation shows that there is need for a truly platform independent Dafny integration in a well established IDE that has a wide user base. \newline
 
\subsubsection{Setup}
This is an area where all current solutions lack comfort. Next to the plugin for the specific IDE, the user must also make sure to install the whole Dafny platform and configure the plugin correctly to make use of it. This is usually done either by editing a configuration file or by using a dialog in the IDE. Next to this being error prone and cumbersome for the user, this process is also dangerous when the IDE and the Dafny platform are further developed. Version updates may introduce breaking changes which will make it unable to work with a plugin if it is not well maintained. \newline
Next to an automatic installation of all components that are necessary, it is important to have some integration tests in place that notify in case of breaking changes, something that is very difficult if the gathering of all dependencies is not done in a single place. \newline

\subsubsection{Usability}
When designing a plugin, one usually does not have many options regarding usability, since the user interacts with the IDE rather than with the plugin. It is therefor important to make usage of the correct mechanisms that an IDE offers, for instance displaying compiler errors in the appropriate window or underlining warnings with the color the IDE uses for warnings also in other languages. When further user interaction is needed, for instance for the application of a refactoring or displaying configuration possibilities of a plugin, IDEs usually offer an idiomatic way to do this.  \newline

The existing solutions do a nice job in this area, if information of the plugins is displayed, it usually is done so using the correct mechanism that the IDE offers for that type of information. Almost all existing solutions sadly only display a subset of the information that the Dafny platform could provide, here new solutions could offer improvements. The exception is the existing Visual Studio integration of Dafny \cite{visualstudiodafny}, which offers almost a complete interaction with the Dafny platform. 
\newline

\subsubsection{IDE Independence}
All existing solutions are hardwired to an existing IDE. This means that when a plugin is written for Visual Studio and one for Emacs, that all features have to be copied and implemented anew. This makes it cumbersome to widen the user range of Dafny users. It also makes the process of updating plugins error prone and asymmetric, since changes have to be done in two places. \newline

When looking at the process of programming a plugin in an abstract way, it comes down to integrating a semantic language analysis framework with an existing IDE. There have been several attempts to unify the way this integration is done, with Microsoft weighing in with a solution for this they call the language server protocol \cite{langserver}, which is quickly gaining traction. When this protocol matures and a solution is written in terms of such the protocol, one can offer plugins for many different IDEs while writing the core logic only once. There exists great potential in following this strategy. 
\newline

\subsubsection{Feature Richness}
Once solutions are installed and running, the most important thing probably is feature richness. Next to standard IDE features, which are a must and expected by programmers, language specific features are what really make a solution stand out. This especially is true for Dafny, since it offers an almost unique and very valuable approach to specification constructs. In this area, most existing solutions perform poorly. Of the very rich information about a program that Dafny provides, only a fractions is presented to the user. \newline

A notable exception to this is the existing Visual Studio integration. It offers virtually all possibilities that Dafny provides in it's GUI. It even integrates counter examples for failed proofs and a debugger. While most existing solutions do not provide many features, the Visual Studio integration is the example that new solutions should try to match regarding feature richness. \newline

