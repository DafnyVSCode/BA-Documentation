\subsection{Dafny VSCode}
Github Repository: \href{https://github.com/FunctionalCorrectness/dafny-vscode}{https://github.com/FunctionalCorrectness/dafny-vscode}

\subsubsection{Overview}
\todo{Maybe add a class diagram}

\subsubsection{VSCode Plugin}
\paragraph{Structure}
\todo{How is a vscode plugin structured, package.json explaination}

\subsubsection{Extension points}

\paragraph{Statusbar}
\paragraph{Refactoring}
\paragraph{CodeLens}
\paragraph{Go to definition}

\subsubsection{Communication}

\subsubsection{Sytax highlighting}

\subsubsection{Snippets}

\subsubsection{Automatic installation}
\paragraph{Windows}

\paragraph{Ubuntu}

\paragraph{OSX}


\subsection{DafnyServer}
Github Repository: \href{https://github.com/FunctionalCorrectness/dafny-microsoft}{https://github.com/FunctionalCorrectness/dafny-microsoft}

The DafnyServer is a simple console application which allows proofing Dafny source files. To verify files, they are sent over the standard input. Results are obtained from the standard output. The verification task needs to be in json format \todo{add reference to source.cs} and is sent base64 encoded. By default the server only supports the verbs verify, quit and selftest. Verbs are sent first followed by a newline \textbackslash{n}. May proceed by a payload and an end string \todo{reference to end string}. 
Verb explanation: Verify needs a verification task and returns if all proofs holds, quit stops the server and selftest execute some simple verification. 

\textbf{Example verification task}
\begin{lstlisting}[language=json,firstnumber=1]
{
	args:[],
	filename:"c:\Users\Markus\Desktop\dafny\test1.dfy",
	source:"method Main() {	assert 1 < 3; }",
	sourceIsFile:false
}

\end{lstlisting}

\subsubsection{symbols}
To support refactorings in the Dafny VSCode plugin, symbol information were needed. All fields, methods and classes inside a file with their position information needed to be accessible. To support that the DafnyServer was extended. A new verb "symbols" was introduced. This returns a json formatted symbol table, of the input file. 
\newline\newline
\textbf{Request: }
\todonl{add request}
\newline\newline
\textbf{Result: }
\begin{lstlisting}[language=json,firstnumber=1]
{[
{
	"Module" : "_module",
	"Name" : "Fibonacci",
	"ParentClass" : "_default",
	"SymbolType" : "Function",
	"Position" : 190,
	"Line" : 17,
	"Column" : 12
}, {
	"Module" : "_module",
	"Name" : "Test",
	"ParentClass" : null,
	"SymbolType" : "Class",
	"Position" : 8,
	"Line" : 2,
	"Column" : 7
}, {
	"Module" : "_module",
	"Name" : "_default",
	"ParentClass" : null,
	"SymbolType" : "Class",
	"Position" : 0,
	"Line" : 0,
	"Column" : 0
}
]}
\end{lstlisting}

\subsubsection{references}
To support CodeLens in the plugin, it was also necessary to get all method references from a given one. To also allow that the verb "references" was also introduced. This task finds all call statements towards a specified method. This has to be specified in the args argument, with the following information: [moduleName, className, methodName]. 
\newline\newline
\textbf{Request: }
\todonl{add request}
\newline\newline
\textbf{Result: }
\begin{lstlisting}[language=json,firstnumber=1]
[{
	"MethodName":"Main3",
	"Position":226,
	"Line":18,
	"Column":8
}] 
\end{lstlisting}


\subsubsection{proofs}
\textbf{Request: }
\begin{lstlisting}[language=json,firstnumber=1]
\todo{Add request}
\end{lstlisting}

\textbf{Result: }
\begin{lstlisting}[language=json,firstnumber=1]
[
	{
		"Proof" : "a#0 != null",
		"Type" : "Assert"
	}, {
		"Proof" : "$w$loop#0 ==> i#0 <= N#0",
		"Type" : "Assert"
	}, {
		"Proof" : "$w$loop#0 ==> sum#0 <= i#0 * max#0",
		"Type" : "Assert"
	}, {
		"Proof" : "a#0 != null",
		"Type" : "Assert"
	}, {
		"Proof" : "0 <= i#0 && i#0 < _System.array.Length(a#0)",
		"Type" : "Assert"
	}, {
		"Proof" : "a#0 != null",
		"Type" : "Assert"
	}, {
		"Proof" : "0 <= i#0 && i#0 < _System.array.Length(a#0)",
		"Type" : "Assert"
	}, {
		"Proof" : "a#0 != null",
		"Type" : "Assert"
	}, {
		"Proof" : "0 <= i#0 && i#0 < _System.array.Length(a#0)",
		"Type" : "Assert"
	}, {
		"Proof" : "0 <= $decr$loop#00 || N#0 - i#0 == $decr$loop#00",
		"Type" : "Assert"
	}, {
		"Proof" : "N#0 - i#0 < $decr$loop#00",
		"Type" : "Assert"
	}
]
\end{lstlisting}




\subsection{DafnyDef}
Github Repository: \href{https://github.com/FunctionalCorrectness/DafnyDef}{https://github.com/FunctionalCorrectness/DafnyDef}

DafnyDef is a simple console application which was added to support various semantic analysis. This was done because the Dafny compiler does not offer any hooks for gaining further insight needed for static code analysis. It was not the scope of this thesis to extend the compiler in a fundamental way, so an approach similar to the GO-Language environment was chosen, were semantic analysis is done via a seperat component called \cite{godef}. \newline
In order to stay consistent with the Dafny and VS-Code environment, input is sent via standard input and output is obtained via standard output of the process. The input format is structured similary to the input format of Dafny Server and is also written in json format and encoded in base64. Commands are also implemented in terms of supported terms, which at this time are quit, findDefinition and getDefinitions. They are followed by a newline \textbackslash{n}, a payload and an endString \todo{reference to end string}. \newline



\subsubsection{findDefinition}
To support the IDE-Feature "go to definition", the command findDefinition was implemented. Its payload consists of a searched for symbol, the path of the file which was open when the command was sent, an optional root directory and if the Dafny Server should be contacted in a mono environment, the path to the mono executable. It then sends requests to the Dafny Server to gain symbol informations about files, starting at the originating file and then either walking the root directory  found in the payload or the directory which the originating file was found in. Once the possible multiple definitions were found, they are returned in a structured way.\newline\newline
\textbf{Request: }
\begin{lstlisting}[language=json,firstnumber=1]
{
args:[],
baseDir:"c:\Users\Markus\Desktop\dafny\",
fileName:"c:\Users\Markus\Desktop\dafny\dafnyTest.dfy",
monoPath: "mono",
word: "printReport"
}

\end{lstlisting}

\textbf{Result: }
\begin{lstlisting}[language=json,firstnumber=1]
{[
{
"Symbol" : "printReport",
"FilePath" : "c:\Users\Markus\Desktop\dafny\dafnyTest.dfy",
"SymbolInfos": [
	{
		"Module" : "_module",
		"Name" : "printReport",
		"ParentClass" : "Reporter",
		"SymbolType" : "method",
		"Position" : 211,
		"Line" : 34,
		"Column" : 2
	},
	{
		"Module" : "_specialReporting",
		"Name" : "printReport",
		"ParentClass" : "SpecialReporter",
		"SymbolType" : "method",
		"Position" : 575,
		"Line" : 67,
		"Column" : 34
	}	
]
}, {
"Symbol" : "printReport",
"FilePath" : ""c:\Users\Markus\Desktop\dafny\dafnyDefinitions.dfy"",
"SymbolInfos": [
	{
		"Module" : "_module",
		"Name" : "printReport",
		"ParentClass" : null,
		"SymbolType" : "function",
		"Position" : 1,
		"Line" : 1,
		"Column" : 1
	},
	{
		"Module" : "_specialInterfaces",
		"Name" : "printReport",
		"ParentClass" : null,
		"SymbolType" : "function",
		"Position" : 311,
		"Line" : 24,
		"Column" : 1
	}	
]
}
]}
\end{lstlisting}


